---
title: "Not coordinated departures to foraging"
author: "Camila Calderon"
date: "2024-02-19"
output: html_document
---

## Install required packages and load libraries

```{r load packages, warning=FALSE, message=FALSE}
# install.packages(c("remotes","devtools","miniCRAN","pacman"), dependencies = TRUE, type="source")
# 
# 
# list_of_required_packages <- c("brms")
# packages_to_install=as.character(miniCRAN::pkgDep(list_of_required_packages, suggests = TRUE, enhances = TRUE))
# install.packages(packages_to_install, type="source")
# 
# install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))

library(lubridate)
library(dplyr)
library(ggplot2)
library(data.table)
library(plyr)
library(raster)
library(ggpubr)
library(gridExtra)
library(brms)
library(cmdstanr)
library(ggplot2)
library(emmeans)
library(tidyverse)
library(data.table)

### install cmdstan and make sure it's configured properly
# install_cmdstan(overwrite=TRUE)
# 
# rebuild_cmdstan()
# 
# cmdstan_make_local(dir = cmdstan_path(), cpp_options = NULL, append = TRUE)
# 
# check_cmdstan_toolchain(fix = FALSE, quiet = FALSE)


```

## Load data

```{r load data}
load(file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript_1/data/Phyllostomus_HMMbehaviors.RData")
```

## Extract foraging points from data set of Colony 1=la Gruta in February

```{r, results=FALSE}
# adding a variable that counts the length of consecutive commuting and foraging points. This will be used to filter only foraging points that contain more than 4 or more points in row and commuting points that have more than 5 or more points in a row
hast_df <- bats_behaviors
hast_df$n <- NA
r <- rle(hast_df$behav)

for(i in 1:length(r$lengths)){
  #if(r$values[i] == "commuting"){
      start <- {}
      end <- {}
      try(start <- sum(r$lengths[1:(i-1)])+1)
      if(i == 1) start <- 1
      end <- sum(r$lengths[1:i])

      hast_df$n[start:end] <- r$lengths[i]
}

#data frame with only tracking from February
bats_feb <- hast_df %>%
 filter(date > "2022-01-01" & date < "2022-03-01")

#split data frame by ID
bats_feb_split <- split(bats_feb, bats_feb$ID)

#foraging spots which >= 3 foraging points and stays longer than 8 minutes
foragingdata <- lapply(bats_feb_split, function(x){
  filter(x, c(behav=="foraging" & n>=4 & location_long<=-82.35))
})

#for some reason one individual has no more than 3 foraging in a row, I had to add it manually
x <- data.frame(bats_feb_split[["39500E37_D.2022-02-04"]]%>%
  filter(behav=="foraging"& location_long<=-82.35))

foragingdata[["39500E37_D.2022-02-04"]] <- x

#take first and last foraging spots
firstforaging <- rbindlist(lapply(foragingdata, function(x){
  dplyr::slice_head(x, n=1)
}))

#This is for the returns which I might not use
lastforaging <- rbindlist(lapply(foragingdata, function(x){
  slice(x, which.max(1:n()))
}))

idday <- unique(bats_feb$ID)

# to know which foraging locations I am selecting
pdf("~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/suplementary/foragingearly2022_check.pdf")
for (i in 1:length(idday)){
  day_phast <- bats_feb[bats_feb$ID == idday[i],]
  day_phast2 <- firstforaging[firstforaging$ID == idday[i],]
    #create plot
   plot(day_phast$location_long, day_phast$location_lat, main=idday[i])
points(day_phast2$location_long, day_phast2$location_lat, col="red")
}
while (!is.null(dev.list()))  
  dev.off()

#filter only commuting with more than 5 points in a row
bats_commufeb <- bats_feb  %>%  
  filter(behav=="commuting" & n>=5)

#take the first row of each id date in the commuting tracks
commu_feb_dep <- bats_commufeb %>%
  group_by(ID) %>%
  slice(which.min(1:n()))

#add columns to data frame
commu_feb_dep$lat_foraging <-  firstforaging$location_lat
commu_feb_dep$long_foraging <-  firstforaging$location_long
commu_feb_dep$timestamp_foraging <-  firstforaging$timestamp
commu_feb_dep$cave_group <-  firstforaging$cave_group
commu_feb_dep$sex <- firstforaging$animal_sex

#split data frame by cave and individuals
commu_feb_dep_cave <- split(commu_feb_dep, f=commu_feb_dep$cave_group)
commu_feb_dep_split <- lapply(commu_feb_dep_cave, function(x){
split(x, x$date)
})

```

## Calculate pairwise distances for groups in la gruta= Colony 1 in early 2022

```{r, results=FALSE}
####### D HAREM - Colony 1 #######
# calculate pairwise distance in foraging spots between individuals
pair.distFOR_D <-  rbindlist(lapply(commu_feb_dep_split[[1]][1:13], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamps))#UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('x', 'y')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('x', 'y')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# calculate pairwise time difference in timestamps between individuals
pair.depdiff_D <-  rbindlist(lapply(commu_feb_dep_split[[1]][1:13], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamps))#UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], data=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('timestamp')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # geographic distance between bats (in meters)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_D <- pair.distFOR_D %>%
  mutate(Deptimediff= abs(pair.depdiff_D$Deptimediff)) %>%
  mutate(cave_group= "LaGruta_D", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

####### G HAREM - Colony 1 #######
# calculate pairwise distance in foraging spots betweeen individuals
pair.distFOR_G <-  rbindlist(lapply(commu_feb_dep_split[[2]], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamps))# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex,stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('x', 'y')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('x', 'y')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# calculate pairwise time difference in timestamps between individuals
pair.depdiff_G <-  rbindlist(lapply(commu_feb_dep_split[[2]], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamps))# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], data=date, sex=sex,stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('timestamp')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # geographic distance between bats (in meters)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_G <- pair.distFOR_G %>%
  mutate(Deptimediff= abs(pair.depdiff_G$Deptimediff)) %>%
  mutate(cave_group= "LaGruta_G", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

# bind two data frames
pair.distFOR <- rbind(pair.distFOR_D, pair.distFOR_G)
pair.distFOR$month <- "february"
# select only the days with enough data, after 11.02.2022 there are only individuals from the D Harem
pair.distFOR <- pair.distFOR %>%
  filter(date<="2022-02-10")

save(pair.distFOR, file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/suplementary/dep_foraging_feb.RData")

# plot for the two caves
ggplot(aes(x=Deptimediff, y=geo.dist, color=as.factor(cave_group), shape=sex), data=pair.distFOR)+
  geom_point()+
  facet_wrap(~date, ncol=3)+
   theme(legend.position="bottom", legend.title = element_blank())+
  ylab("pairwise distances between first foraging location (m)")+
  xlab("time departure difference (mins)")
```

## Extract foraging points for data collected in late 2022

```{r, results=FALSE}
# filter march data of 2022
bats_march_f <- hast_df %>% 
 filter(date(timestamp) > "2022-03-01" )#& animal_sex=="f")

# split data
bats_march_split_f <- split(bats_march_f, bats_march_f$ID)

# include all individual with complete data
bats_march_f_com <- bats_march_split_f[names(bats_march_split_f) %in% c("PH_TS_018.2022-03-08", "PH_TS_018.2022-03-09", "PH_TS_018.2022-03-10", "PH_TS_018.2022-03-11","PH_TS_018.2022-03-13", "PH_TS_039.2022-03-08", "PH_TS_039.2022-03-09","PH_TS_039.2022-03-10", "PH_TS_046.2022-03-08", "PH_TS_046.2022-03-09", "PH_TS_046.2022-03-10", "PH_TS_046.2022-03-11",  "PH_TS_049.2022-03-08", "PH_TS_049.2022-03-09", "PH_TS_056.2022-03-08", "PH_TS_056.2022-03-09", "PH_TS_062.2022-03-07", "PH_TS_062.2022-03-08", "PH_TS_062.2022-03-09", "PH_TS_062.2022-03-10", "PH_TS_062.2022-03-11", "PH_TS_072.2022-03-08", "PH_TS_072.2022-03-09", "PH_TS_072.2022-03-10", "PH_TS_072.2022-03-11", "PH_TS_072.2022-03-12","PH_TS_072.2022-03-16", "PH_TS_072.2022-03-19", "PH_TS_072.2022-03-20", "PH_TS_081.2022-03-08", "PH_TS_081.2022-03-09", "PH_TS_081.2022-03-10", "PH_TS_081.2022-03-11", "PH_TS_081.2022-03-12", "PH_TS_081.2022-03-18", "PH_TS_096.2022-03-09", "PH_TS_096.2022-03-10", "PH_TS_096.2022-03-11", "PH_TS_103.2022-03-08", "PH_TS_103.2022-03-09", "PH_TS_103.2022-03-11", "PH_TS_103.2022-03-12",  "PH_TS_011.2022-03-07", "PH_TS_011.2022-03-08", "PH_TS_011.2022-03-09", "PH_TS_011.2022-03-10", "PH_TS_011.2022-03-11","PH_TS_011.2022-03-12", "PH_TS_011.2022-03-13", "PH_TS_011.2022-03-14","PH_TS_011.2022-03-15", "PH_TS_011.2022-03-16", "PH_TS_011.2022-03-17", "PH_TS_014.2022-03-07", "PH_TS_014.2022-03-08", "PH_TS_014.2022-03-09", "PH_TS_014.2022-03-10","PH_TS_014.2022-03-12", "PH_TS_014.2022-03-14", "PH_TS_014.2022-03-16","PH_TS_016.2022-03-08", "PH_TS_016.2022-03-09","PH_TS_016.2022-03-10","PH_TS_016.2022-03-11", "PH_TS_016.2022-03-12", "PH_TS_016.2022-03-14", "PH_TS_074.2022-03-08", "PH_TS_074.2022-03-09", "PH_TS_074.2022-03-10", "PH_TS_074.2022-03-11", "PH_TS_074.2022-03-12", "PH_TS_079.2022-03-07", "PH_TS_079.2022-03-08", "PH_TS_079.2022-03-09", "PH_TS_079.2022-03-10", "PH_TS_079.2022-03-11", "PH_TS_079.2022-03-12", "PH_TS_079.2022-03-13", "PH_TS_079.2022-03-14", "PH_TS_079.2022-03-15", "PH_TS_079.2022-03-16","PH_TS_079.2022-03-17", "PH_TS_079.2022-03-18", "PH_TS_080.2022-03-08", "PH_TS_080.2022-03-09", "PH_TS_080.2022-03-10", "PH_TS_080.2022-03-11", "PH_TS_080.2022-03-12", "PH_TS_080.2022-03-13",  "PH_TS_080.2022-03-14", "PH_TS_080.2022-03-15", "PH_TS_080.2022-03-16", "PH_TS_080.2022-03-17", "PH_TS_080.2022-03-18", "PH_TS_080.2022-03-19", "PH_TS_080.2022-03-20", "PH_TS_080.2022-03-21", "PH_TS_083.2022-03-08", "PH_TS_083.2022-03-09", "PH_TS_083.2022-03-10", "PH_TS_083.2022-03-11", "PH_TS_112.2022-03-07", "PH_TS_112.2022-03-08", "PH_TS_112.2022-03-09", "PH_TS_112.2022-03-10", "PH_TS_112.2022-03-11", "PH_TS_112.2022-03-12", "PH_TS_113.2022-03-08", "PH_TS_113.2022-03-09", "PH_TS_113.2022-03-12", "PH_TS_120.2022-03-08", "PH_TS_120.2022-03-08", "PH_TS_120.2022-03-09", "PH_TS_120.2022-03-10", "PH_TS_120.2022-03-11", "PH_TS_120.2022-03-13", "PH_TS_121.2022-03-08", "PH_TS_121.2022-03-09", "PH_TS_121.2022-03-10", "PH_TS_121.2022-03-11", "PH_TS_121.2022-03-14") == TRUE]

# convert to data frame
bats_march_f_df <- do.call(rbind, bats_march_f_com)

# extract individuals from muddy cave
bats_march_muddy <- bats_march_f_com[names(bats_march_f_com) %in% c("PH_TS_046.2022-03-08", "PH_TS_046.2022-03-09", "PH_TS_046.2022-03-10","PH_TS_046.2022-03-11", "PH_TS_056.2022-03-08", "PH_TS_056.2022-03-09", "PH_TS_062.2022-03-07", "PH_TS_062.2022-03-08", "PH_TS_062.2022-03-09", "PH_TS_062.2022-03-10", "PH_TS_062.2022-03-11", "PH_TS_072.2022-03-08", "PH_TS_072.2022-03-09", "PH_TS_072.2022-03-10", "PH_TS_072.2022-03-11", "PH_TS_072.2022-03-12","PH_TS_072.2022-03-16", "PH_TS_072.2022-03-19", "PH_TS_072.2022-03-20")==TRUE]#"PH_TS_049_2022-03-08", "PH_TS_049_2022-03-09", remove because is not in the commuting table from the acc

# remove some other individuals from AJ cave
bats_march_grut_aj <- bats_march_f_com[names(bats_march_f_com) %in% c("PH_TS_049.2022-03-08", "PH_TS_049.2022-03-09","PH_TS_046.2022-03-08", "PH_TS_046.2022-03-09", "PH_TS_046.2022-03-10","PH_TS_046.2022-03-11", "PH_TS_056.2022-03-08", "PH_TS_056.2022-03-09", "PH_TS_062.2022-03-07", "PH_TS_062.2022-03-08", "PH_TS_062.2022-03-09", "PH_TS_062.2022-03-10", "PH_TS_062.2022-03-11", "PH_TS_072.2022-03-08", "PH_TS_072.2022-03-09", "PH_TS_072.2022-03-10", "PH_TS_072.2022-03-11", "PH_TS_072.2022-03-12","PH_TS_072.2022-03-16", "PH_TS_072.2022-03-19", "PH_TS_072.2022-03-20")==FALSE]

# filter foraging points in colony 3
foragingdata_march_muddy <- lapply(bats_march_muddy, function(x){
  filter(x, c(behav=="foraging" & n>=4) & location_long<=9.35)
})

# filter foraging points n colony 1 and 2. Foraging spots which >= 4 and stays longer than 8 minutes
foragingdata_march_aj_gru<- lapply(bats_march_grut_aj, function(x){
  filter(x, c(behav=="foraging" & n>=4 & location_long<=-82.38))
})

# merge the two data frames
foraging_march <- c(foragingdata_march_aj_gru,foragingdata_march_muddy)

# take first foraging spots
firstforaging_march_fc<- rbindlist(lapply(foraging_march, function(x){
  slice_head(x, n=1)
}))

# order by ID
firstforaging_march_fc <- firstforaging_march_fc[order(firstforaging_march_fc$ID),]

# take last foraging spots
lastforaging_march_fc <- rbindlist(lapply(foraging_march, function(x){
  slice(x, which.max(1:n()))
}))

idday2 <- unique(bats_march_f_df$ID)

# check that first foraging points are good
pdf("~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/suplementary/foraginglate2022_check.pdf")

for (i in 1:length(idday2)){
  day_phast <- bats_march_f_df[bats_march_f_df$ID == idday2[i],]
  day_phast2 <- firstforaging_march_fc[firstforaging_march_fc$ID == idday2[i],]
    #create plot
   plot(day_phast$location_long, day_phast$location_lat, main=idday2[i], type="b")
points(day_phast2$location_long, day_phast2$location_lat, col="red")
}
while (!is.null(dev.list()))  
  dev.off()

# load commuting from acc data extracted manually using the Firetail program
library(readxl)

commuting_dep_ret <- read_csv("~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript_1/data/departures_returns_march.csv")
# add date
commuting_dep_ret$date <- date(commuting_dep_ret$departure_start)

# extract tag id and include in the data frame
commuting_dep_ret$tag_local_identifier <- sapply(strsplit(commuting_dep_ret$Tag,  '[.]'), `[`, 1)
commu_march_dep <- commuting_dep_ret %>%
  filter(`use in analysis`=="yes") 
#order data frame by id
commu_march_dep <- commu_march_dep[order(commu_march_dep$Tag),]
firstforaging_march_fc <- firstforaging_march_fc[order(firstforaging_march_fc$ID),]

#insert location of foraging in the data frame
commu_march_dep$lat_foraging_dep <-  firstforaging_march_fc$y
commu_march_dep$long_foraging_dep <-  firstforaging_march_fc$x
commu_march_dep$lat_foraging_ret <-  lastforaging_march_fc$y
commu_march_dep$long_foraging_ret <-  lastforaging_march_fc$x
commu_march_dep$timestamp_foraging <-  firstforaging_march_fc$timestamp

# split the data frame by cave and id
commu_march_dep_f_cave <- split(commu_march_dep, commu_march_dep$cave_group)
commu_march_dep_f_split <- lapply(commu_march_dep_f_cave, function(x){
  split(x, x$date)
})
```

## Calculate pairwise distances for data in late 2022

```{r, results=FALSE}
#### COLONY 2 ####
## calculate pairwise distance in foraging spots betweeen individuals
pair.distFOR_aj <-  rbindlist(lapply(commu_march_dep_f_split[[1]][2:5], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$sex, 2))
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('long_foraging_dep', 'lat_foraging_dep')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('long_foraging_dep', 'lat_foraging_dep')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))

## calculate pairwise time difference in timestamps between individuals
pair.depdiff_aj <-  rbindlist(lapply(commu_march_dep_f_split[[1]][2:5], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$sex, 2))
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('departure_start')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'departure_start'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # geographic distance between bats (in meters)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_aj <- pair.distFOR_aj %>%
  mutate(Deptimediff= abs(pair.depdiff_aj$Deptimediff)) %>%
  mutate(cave_group= "aj_cave", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

#### COLONY 1 ####
## calculate pairwise distance in foraging spots betweeen individuals
pair.distFOR_lagruta <-  rbindlist(lapply(commu_march_dep_f_split[[2]][1:4], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$sex, 2))
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('long_foraging_dep', 'lat_foraging_dep')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('long_foraging_dep', 'lat_foraging_dep')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))

## calculate pairwise time difference in timestamps between individuals
pair.depdiff_lagruta <-  rbindlist(lapply(commu_march_dep_f_split[[2]][1:4], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$sex, 2))
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('departure_start')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'departure_start'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # geographic distance between bats (in meters)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_lagruta <- pair.distFOR_lagruta %>%
  mutate(Deptimediff= abs(pair.depdiff_lagruta$Deptimediff)) %>%
  mutate(cave_group= "lagruta_cave", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

#### COLONY 3 ####
## calculate pairwise distance in foraging spots between individuals
pair.distFOR_muddy <-  rbindlist(lapply(commu_march_dep_f_split[[3]][2:5], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$sex, 2))
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('long_foraging_dep', 'lat_foraging_dep')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('long_foraging_dep', 'lat_foraging_dep')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))


## calculate pairwise time difference in timestamps between individuals
pair.depdiff_muddy <-  rbindlist(lapply(commu_march_dep_f_split[[3]][2:5], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$sex, 2))
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('departure_start')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'departure_start'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # geographic distance between bats (in meters)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_muddy <- pair.distFOR_muddy %>%
  mutate(Deptimediff= abs(pair.depdiff_muddy$Deptimediff)) %>%
  mutate(cave_group= "muddy_cave", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

# join all dataframes together
pair.distFOR_dep_march <- rbind(pair.distFOR_aj, pair.distFOR_lagruta, pair.distFOR_muddy)
pair.distFOR_dep_march$month <- "march"

save(pair.distFOR_dep_march, file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/data/dep_foraging_march.RData")

# plot difference in time of departures vs. distance to first foraging spot
ggplot(aes(x=Deptimediff, y=geo.dist, color=as.factor(cave_group), shape=sex), data=pair.distFOR_dep_march)+
  geom_point()+
  facet_wrap(~date, ncol=3)+
  theme(legend.position="bottom", legend.title = element_blank())+
  ylab("pairwise distances between first foraging locations (m)")+
  xlab("time departure difference (mins)")
```

## Extract foraging points for data in 2016

```{r, results=FALSE}
# filter data of 2016
bats_2016 <- hast_df %>% 
 filter(date(timestamp) < "2021-01-01" )

# split data frame by ID_day
bats_2016_split <- split(bats_2016, bats_2016$ID)

# foraging spots which >= 4 foraging points and stays longer than 8 minutes
foragingdata <- lapply(bats_2016_split, function(x){
  filter(x, c(behav=="foraging" & n>=4 & location_long<=-82.38))
})

# take first foraging spots
firstforaging <- rbindlist(lapply(foragingdata, function(x){
  slice_head(x, n=1)
}))

# take last foraging spots
lastforaging <- rbindlist(lapply(foragingdata, function(x){
  slice(x, which.max(1:n()))
}))

idday <- unique(bats_2016$ID)

# check which foraging locations I am selecting
pdf("~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/suplementary/foragingpoints2016.pdf")

for (i in 1:length(idday)){
  day_phast <- bats_2016[bats_2016$ID == idday[i],]
  day_phast2 <- firstforaging[firstforaging$ID == idday[i],]
    #create plot
   plot(day_phast$location_long, day_phast$location_lat, main=idday[i])
points(day_phast2$location_long, day_phast2$location_lat, col="red")
}
while (!is.null(dev.list()))  
  dev.off()

# filter only commuting with more than 10 points in a row
bats_commu2016 <- bats_2016  %>% 
  filter(behav=="commuting" & n>=10)

ggplot(aes(x=location_long, y=location_lat, col=tag_local_identifier), data=bats_commu2016) + geom_point()

# take the first row of each id date in the commuting tracks
commu_2016_dep <- bats_commu2016 %>%
  group_by(ID) %>%
  slice(which.min(1:n()))

# filter id with no foraging
commu_2016_dep <- commu_2016_dep %>%
  filter(ID!="74D972D_2016-03-04")

#add columns to data frame
commu_2016_dep$lat_foraging <-  firstforaging$location_lat
commu_2016_dep$long_foraging <-  firstforaging$location_long
commu_2016_dep$timestamp_foraging <-  firstforaging$timestamp
commu_2016_dep$cave_group <-  firstforaging$cave_group
commu_2016_dep$sex <- firstforaging$sex

#split data frame by cave and individuals
commu_2016_dep_cave <- split(commu_2016_dep, f=commu_2016_dep$cave_group)
commu_2016_dep_split <- lapply(commu_2016_dep_cave, function(x){
split(x, x$date)
})
```

## Calculate pairwise distances in 2016 by group

```{r, results=FALSE}
####### Group1 - Colony 1 #######

# calculate pairwise distance in foraging spots between individuals
pair.distFOR_1 <-  rbindlist(lapply(commu_2016_dep_split[[1]][1], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamps))
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('x', 'y')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('x', 'y')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# calculate pairwise time difference in timestamps between individuals
pair.depdiff_1 <-  rbindlist(lapply(commu_2016_dep_split[[1]][1], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamp))
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], data=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('timestamp')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # time difference between bats (in minutes)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_1 <- pair.distFOR_1 %>%
  mutate(Deptimediff= abs(pair.depdiff_1$Deptimediff)) %>%
  mutate(cave_group= "LaGruta_1", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

####### HAREM 3- Colony 1 #######
# calculate pairwise distance in foraging spots betweeen individuals
pair.distFOR_3 <-  rbindlist(lapply(commu_2016_dep_split[[3]], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamp))
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date= date, sex=sex,stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$geo.dist <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('x', 'y')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], c('x', 'y')] # location for second bat
    return(pointDistance(pos.bat1, pos.bat2, lonlat = FALSE))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# calculate pairwise time difference in timestamps between individuals
pair.depdiff_3 <-  rbindlist(lapply(commu_2016_dep_split[[3]], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  sex= t(combn(t$animal_sex, 2))
  date <- unique(date(t$timestamp))
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], data=date, sex=sex,stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate geographic distance between all pairs (in meters!!)
    pos.bat1 <- t[t$tag_local_identifier==combi$bat1[i], c('timestamp')] # location for first bat
    pos.bat2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # location for second bat
    return(pos.bat1 - pos.bat2)})) # geographic distance between bats (in meters)
  return(combi)
  }))

# insert time difference to the of pairwise distances 
pair.distFOR_3 <- pair.distFOR_3 %>%
  mutate(Deptimediff= abs(pair.depdiff_3$Deptimediff)) %>%
  mutate(cave_group= "LaGruta_3", sex=paste(sex.1, sex.2, sep=""), bats=paste(bat1, bat2, sep="."))

# join two data frames
pair.distFOR2016 <- rbind(pair.distFOR_1, pair.distFOR_3)
pair.distFOR2016$month <- "march"
pair.distFOR2016 <-  pair.distFOR2016 %>% 
  filter(date<"2016-03-06")

save(pair.distFOR2016, file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/data/dep_foraging_2016.RData")

# plot for time departure difference vs. pairwise distance 
ggplot(aes(x=Deptimediff, y=geo.dist, color=as.factor(cave_group), shape=sex), data=pair.distFOR2016)+
  geom_point()+
  facet_wrap(~date, ncol=3)+
   theme(legend.position="bottom", legend.title = element_blank())+
  ylab("pairwise distances between first foraging location (m)")+
  xlab("time departure difference (mins)")

```

## Bayesian model to test if bats that depart together stay together in the foraging areas

```{r}
dep_foraging_all <- rbind(pair.distFOR2016, pair.distFOR ,pair.distFOR_dep_march)

# change sex mf(male-female) to be fm (female-male)
dep_foraging_all$sex[which(dep_foraging_all$sex=="mf")] <- "fm"
unique(dep_foraging_all$sex)
#save data frame
save(dep_foraging_all, file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript_1/data/dep_foraging_all_01.30.2023.RData")
load(file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript_1/data/dep_foraging_all_01.30.2023.RData")

# cave group as factor
dep_foraging_all$cave_group <- as.factor(dep_foraging_all$cave_group)

dep_foraging_all$cave_group <- factor(dep_foraging_all$cave_group, levels= c("LaGruta_3", "LaGruta_G", "LaGruta_D",  "lagruta_cave", "aj_cave", "muddy_cave"), labels = c("colony 1-2016","colony 1-2022-1","colony 1-2022-1", "colony 1-2022-2", "colony 2-2022","colony 3-2022"))

# brief summary statistics
library(Rmisc)
sum_dep<-  summarySE(dep_foraging_all, measurevar="Deptimediff", groupvars=c("cave_group"))

# run a model
options(mc.cores = parallel::detectCores()) 

mod=brm(geo.dist ~ Deptimediff + sex:Deptimediff + cave_group + (1|bats), 
                 data=dep_foraging_all,
                 family = Gamma(link = "log"),
                 iter = 2000,
                 init = 0,
                 prior = c(
                   prior(student_t(3, 0, 5), class = Intercept),
                   prior(student_t(3, 0, 5), class = sd ),
                   prior(student_t(3, 0, 5), class = b )
                 ),
                 save_pars = save_pars(all = TRUE),
                 backend = "cmdstanr",
                 control = list(max_treedepth = 10, adapt_delta = .9))

mod=add_criterion(mod, c("loo", "loo_R2"),
              reloo = TRUE,
              backend = "cmdstanr",
              control = list(max_treedepth = 10, adapt_delta = .9))

#save(mod, file = "~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/data/mod_depforaging.rda")
load("~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript_1/data/mod_depforaging.rda")

pp_check(mod)
summary(mod, digits=9) 
library(report)
report(mod)
report_table(mod)

```
We fitted a Bayesian general linear mixed model (gamma family with a log link)
(estimated using MCMC sampling with 4 chains of 2000 iterations and a warmup of 1000) to
predict geo.dist with Deptimediff, sex and cave_group (formula: geo.dist ~ Deptimediff +
sex:Deptimediff + cave_group). The model included bats as random effect (formula: ~1 |
bats). Priors over parameters were set as student_t (location = 0.00, scale = 5.00)
distributions. The model's explanatory power is substantial (R2 = 0.48, 95% CI [0.34,
0.63]) and the part related to the fixed effects alone (marginal R2) is of 0.48 (95% CI
[0.32, 0.61]).  Within this model:

Following the Sequential Effect eXistence and sIgnificance Testing (SEXIT) framework, we
report the median of the posterior distribution and its 95% CI (Highest Density
Interval), along the probability of direction (pd), the probability of significance and
the probability of being large. The thresholds beyond which the effect is considered as
significant (i.e., non-negligible) and large are |0.05| and |0.30|. Convergence and
stability of the Bayesian sampling has been assessed using R-hat, which should be below
1.01 (Vehtari et al., 2019), and Effective Sample Size (ESS), which should be greater
than 1000 (Burkner, 2017). and We fitted a Bayesian general linear mixed model (gamma
family with a log link) (estimated using MCMC sampling with 4 chains of 2000 iterations
and a warmup of 1000) to predict geo.dist with Deptimediff, sex and cave_group (formula:
geo.dist ~ Deptimediff + sex:Deptimediff + cave_group). The model included bats as
random effect (formula: ~1 | bats). Priors over parameters were set as gamma (location =
, scale = ) distributions. The model's explanatory power is substantial (R2 = 0.48, 95%
CI [0.34, 0.63]) and the part related to the fixed effects alone (marginal R2) is of
0.48 (95% CI [0.32, 0.61]).  Within this model:

  - The effect of b Intercept (Median = 9.01, 95% CI [8.69, 9.36]) has a 100.00%
probability of being positive (> 0), 100.00% of being significant (> 0.05), and 100.00%
of being large (> 0.30). The estimation successfully converged (Rhat = 1.000) and the
indices are reliable (ESS = 3000)
  - The effect of b Deptimediff (Median = 7.30e-04, 95% CI [-4.46e-03, 6.33e-03]) has a
61.48% probability of being positive (> 0), 0.00% of being significant (> 0.05), and
0.00% of being large (> 0.30). The estimation successfully converged (Rhat = 1.000) and
the indices are reliable (ESS = 3859)
  - The effect of b cave groupcolony1M2022M1 (Median = -1.64, 95% CI [-2.00, -1.31]) has a
100.00% probability of being negative (< 0), 100.00% of being significant (< -0.05), and
100.00% of being large (< -0.30). The estimation successfully converged (Rhat = 1.001)
and the indices are reliable (ESS = 3138)
  - The effect of b cave groupcolony1M2022M2 (Median = 0.87, 95% CI [0.38, 1.38]) has a
100.00% probability of being positive (> 0), 99.92% of being significant (> 0.05), and
98.90% of being large (> 0.30). The estimation successfully converged (Rhat = 0.999) and
the indices are reliable (ESS = 4463)
  - The effect of b cave groupcolony2M2022 (Median = -0.69, 95% CI [-1.07, -0.35]) has a
100.00% probability of being negative (< 0), 99.98% of being significant (< -0.05), and
98.88% of being large (< -0.30). The estimation successfully converged (Rhat = 1.000)
and the indices are reliable (ESS = 5313)
  - The effect of b cave groupcolony3M2022 (Median = -0.50, 95% CI [-1.11, 0.16]) has a
93.60% probability of being negative (< 0), 91.60% of being significant (< -0.05), and
74.52% of being large (< -0.30). The estimation successfully converged (Rhat = 1.000)
and the indices are reliable (ESS = 6322)
  - The effect of b Deptimediff × sexfm (Median = -4.31e-03, 95% CI [-0.01, 3.50e-03]) has
a 86.02% probability of being negative (< 0), 0.00% of being significant (< -0.05), and
0.00% of being large (< -0.30). The estimation successfully converged (Rhat = 1.000) and
the indices are reliable (ESS = 5092)
  - The effect of b Deptimediff × sexmm (Median = -0.02, 95% CI [-0.02, -8.47e-03]) has a
100.00% probability of being negative (< 0), 0.00% of being significant (< -0.05), and
0.00% of being large (< -0.30). The estimation successfully converged (Rhat = 1.001) and
the indices are reliable (ESS = 2985)

Following the Sequential Effect eXistence and sIgnificance Testing (SEXIT) framework, we
report the median of the posterior distribution and its 95% CI (Highest Density
Interval), along the probability of direction (pd), the probability of significance and
the probability of being large. The thresholds beyond which the effect is considered as
significant (i.e., non-negligible) and large are |0.05| and |0.30|. Convergence and
stability of the Bayesian sampling has been assessed using R-hat, which should be below
1.01 (Vehtari et al., 2019), and Effective Sample Size (ESS), which should be greater
than 1000 (Burkner, 2017).

The intercept represents the mean of log in y when x is zero. So a value of 0.01 for the intercept would indicate a mean of exp(8.45) = 4675.073

slope: In words, this means that the value of y increases by a factor of exp(0.0)=1 for every increase in x. For example indicates that for a unit increase in perature time differece for la colony 1 group D, the response is multiplied by exp(-0.00 - 1.03) = 0.35. If you multiply something by this value it gets smaller. By how much depends on what the value of the response was at the value of x before you increase it by the unit of 1.

## Plot conditional and marginal effects, and posterior distributions of the model

Explanation of conditional and marginal effects can be found here <https://www.andrewheiss.com/blog/2022/11/29/conditional-marginal-marginaleffects/>

We can find two different kinds of effects given this type of multilevel model: we can look at the effect of x1 or x2 in one typical group, or we can look at the effect of x1 or x2 across all groups on average.

-   Conditional effects= average group

-   Marginal effects = groups on average

    Marginal effects refer to the global- or population-level effect of a variable. In multilevel models, coefficients can have random group-specific offsets to a global mean.

```{r, results=FALSE}
# plot model fits
plot(mod)

# plot conditional effect
plot(conditional_effects(mod, Spaghetti = FALSE, method="fitted"),points = TRUE) 

# extract r coeficient of the model
loo_R2(mod) 
bayes_R2(mod)

# calculate coefficients
emmeans(mod, specs = pairwise ~ cave_group) # compute marginal means for groups
results=summary(mod, digits=9)
results=data.frame(results$fixed)
results$covariate=rownames(results)
results$covariate=c("Intercept", "time difference", "lagruta feb 2022", "lagruta march 2022", "ajcave 2022", "muddycave 2022", "time diff:sexfm",  "time diff:sexmm")

# plot CI of coefficients, significant if they exclude 0
order_level <- c("Intercept", "time difference","time diff:sexfm","time diff:sexmm", "lagruta feb 2022",  "lagruta march 2022", "ajcave 2022", "muddycave 2022")

# plot 
posteriors=ggplot(results,aes(x=Estimate,y=factor(covariate, level=order_level), color=factor(covariate, level=order_level)))+
  geom_point()+
  geom_linerange(aes(xmin=l.95..CI,xmax=u.95..CI))+
  scale_color_manual(values=c("black","black","black","black", "#21918c", "#21918c","#440154","#fde725"))+ #"#9933FF", "#660099","#339900","#FF9933" 
  scale_y_discrete(labels=c("Intercept", "time difference", "time diff:sexfm",  "time diff:sexmm","colony 1 early 2022 ", "colony 1 late 2022", "colony 2 2022", "colony 3 2022"))+
  ylab("covariate")+
  geom_vline(xintercept = 0)+theme_classic()+theme(legend.position = "none")
posteriors

ggsave("~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/figures/FigS3.pdf", dpi = 300)
```

## Plot regression lines for colony 1 and colony 2

```{r, results=FALSE}
library(tidybayes) 
library(modelr)

# group mean of predicted values
pred_all <- dep_foraging_all %>%
  group_by(cave_group, bats, sex) %>%
  data_grid(Deptimediff = seq_range(0:60, n =101)) %>% # predicts outside of data, but makes lines smooth
  add_linpred_draws(mod) %>%
  mutate(.linpred = exp(.linpred)) # exp converts back to the real scale

# plot regression lines for all groups

# departures_regression <-  ggplot(aes(x = Deptimediff, y = .linpred, color = ordered(cave_group)),  data=pred_all) +
#   stat_lineribbon(.width = c(.95, .75, .50), fill="grey", alpha = 0.25) +
#   #stat_smooth(geom = "ribbon", aes(group = .draw), fill="grey")+
#   geom_point(aes(x = Deptimediff, y = geo.dist, color = ordered(cave_group)), data = dep_foraging_all, size = 1, 
#              shape = 1,) +
#   scale_color_manual(values = c("#CC99FF", "#9933FF", "#660099","#339900","#FF9933"))+
#   #geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black", size = 1, alpha = 0.5) +
#   scale_y_continuous(trans = 'log10')+
#   coord_cartesian(xlim = c(0,60)) +
#   facet_wrap(. ~ cave_group, scales = "free_x")+
#   theme_linedraw()+
#   ylab("pairwise distances between \n first foraging locations (m)")+
#   xlab("time departure difference (mins)")+
#   guides(fill="none", color="none")
# departures_regression

# plot regression lines only for colony 1 early 2022 and colony 2 late 2022
#  adds draws from the posterior linear predictors to the data.
pred_all_sb <- pred_all %>% 
  filter(cave_group=="colony 1-2022-1" | cave_group=="colony 2-2022")

# labeler which is not needed anymore
# cave_names <- as_labeller(
#      c(`colony 1-2022-1` = "colony 1 2022 early", `colony 2-2022` = "colony 2 2022"))

# filter from data frame
dep_foraging_all_sb <- dep_foraging_all %>%
  filter(cave_group=="colony 1-2022-1" | cave_group=="colony 2-2022")

# plot only a subset of the data
# plot posterior predictive intervals 
regression_Fig2B <-  ggplot(aes(x = Deptimediff, y = .linpred, color = ordered(cave_group)),  data=pred_all_sb) +
  stat_lineribbon(.width = c(.95, .75, .50), fill="grey", alpha = 0.25) +
  #stat_smooth(geom = "ribbon", aes(group = .draw), fill="grey")+
  geom_point(aes(x = Deptimediff, y = geo.dist, color = ordered(cave_group)), data = dep_foraging_all_sb, size = 1, 
             shape = 1,) +
  scale_color_manual(values = c("#21918c","#440154"))+#"#9933FF","#339900"
  #geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black", size = 1, alpha = 0.5) +
  scale_y_continuous(trans = 'log10')+
  coord_cartesian(xlim = c(0,60)) +
  facet_wrap(. ~ cave_group, scales = "free_x", nrow=2)+#labeller = cave_names
  theme_linedraw()+
  ylab("pairwise distances between \n first foraging locations (m)")+
  xlab("departure time difference (mins)")+
  guides(fill="none", color="none")+
  theme(axis.text.x = element_text(size = 14),
  axis.text.y = element_text(size = 14),
  axis.title.x = element_text(size = 18),
  axis.title.y = element_text(size = 18), 
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 12),
  axis.title= element_text(size = 18),
  strip.text=element_blank(), 
  panel.grid.major.x = element_blank(),
  panel.grid.major.y = element_blank(),
  panel.background = element_rect(fill = "white"))

regression_Fig2B

ggsave(file="~/ownCloud/PhDLife/P.hastatus/2021-10-Camila-secondseason/Analysis/Manuscript/figures/Fig3.pdf", dpi=300)
```
